package Libraries.Development.Environment.Studio.Interface

use Libraries.Interface.Controls.TextBox
use Libraries.Language.Compile.Symbol.SymbolTable
use Libraries.Development.Environment.Studio.Build.BuildManager
use Libraries.Language.Compile.Symbol.Class
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Symbol.Action
use Libraries.Language.Compile.Symbol.Block
use Libraries.Interface.Events.SelectionListener
use Libraries.Game.GameStateManager
use Libraries.Game.Game
use Libraries.Interface.Events.SelectionEvent
use Libraries.Game.Graphics.Color
use Libraries.Interface.Controls.TextStyles.ColoredHighlight
use Libraries.Interface.Controls.TextStyles.TextStyle
use Libraries.Language.Debug.BreakpointListener
use Libraries.Language.Debug.BreakpointEvent
use Libraries.Language.Debug.Breakpoint
use Libraries.Language.Compile.Lexer
use Libraries.Containers.Array
use Libraries.Language.Compile.Token
use Libraries.Containers.MultipleLineText
use Libraries.Interface.Controls.LineNumberGutter
use Libraries.Game.Graphics.Font
use Libraries.System.File
use Libraries.Interface.Events.GutterListener
use Libraries.Interface.Events.GutterEvent

class CodeTextBox is TextBox, SelectionListener, BreakpointListener, GutterListener
    public constant text CODE_BOX_INPUT_GROUP = "Code Box Input Group"
    BuildManager manager = undefined
    text staticKey = ""
    Class clazz = undefined
    public constant text CARET_STYLE = "Caret"
    Color caretColor
    Color breakpointColor
    Array<Token> lexer = undefined
    Lexer categories
    LineNumberGutter gutter

    on create
        GameStateManager manager
        Game game = manager:GetGame()
        game:AddSelectionListener(me)
        caretColor:SetColor(233.0/255.0, 239.0/255.0, 248.0/255.0, 1.0)
        breakpointColor:SetColor(252.0/255.0, 157.0/255.0, 159.0/255.0, 1.0)
        Add(gutter)
        gutter:AddGutterListener(me)
    end

    action GutterClicked(GutterEvent event)
        integer line = event:GetLine()
        if clazz not= undefined
            File file = clazz:GetFile()
            manager:ToggleBreakpoint(file, line)
        end
    end

    action SelectionChanged(SelectionEvent selection)
        Item item = selection:GetItem()
        if item:GetHashCode() = me:GetHashCode()
            integer caret = GetCaretPosition()
            boolean value1 = RemoveTextStyle(CARET_STYLE)

            boolean hasBreakpoint = HasTextStyle("Breakpoint" + GetCaretLine())
            if not hasBreakpoint
                ColoredHighlight caretHighlight
                caretHighlight:SetColor(caretColor)
                caretHighlight:SetLineHighlight(true)
                TextStyle caretStyle
                caretStyle:SetIndex(caret)
                caretStyle:SetHighlight(caretHighlight)
                AddTextStyle(CARET_STYLE, caretStyle)
            end
        end
    end

    action ToggledBreakpoint(BreakpointEvent event)
        if event:IsAdded()
            Breakpoint bp = event:GetBreakpoint()
            integer line = bp:GetLine()
            ColoredHighlight breakpointHighlight
            breakpointHighlight:SetColor(breakpointColor)
            breakpointHighlight:SetLineHighlight(true)
            TextStyle breakpointStyle
            breakpointStyle:SetIndex(GetIndexOfLine(line))
            breakpointStyle:SetHighlight(breakpointHighlight)
            AddTextStyle("Breakpoint" + bp:GetLine(), breakpointStyle)
        else
            Breakpoint bp = event:GetBreakpoint()
            integer line = bp:GetLine()
            RemoveTextStyle("Breakpoint" + bp:GetLine())
        end
    end

    action GetBuildManager returns BuildManager
        return manager
    end

    action SetBuildManager(BuildManager manager)
        me:manager = manager
        manager:Add(me)
    end

    action GetStaticKey returns text
        return staticKey
    end

    action SetStaticKey(text key)
        me:staticKey = key
    end

    action GetClass returns Class
        return clazz
    end

    action SetClass(Class clazz)
        me:clazz = clazz
    end

    action GetLexer returns Array<Token>
        return lexer
    end

    action SetLexer(Array<Token> lexer)
        me:lexer = lexer
    end

    action SmartNavigateUp
        if clazz = undefined
            return now
        end

        integer line = GetCaretLine()
        Action closest = FindPreviousAction(line)

        if closest not= undefined and closest:GetLineNumber() > 0
            NavigateTo(closest:GetLineNumber())
        end
    end

    action SmartNavigateDown
        if clazz = undefined
            return now
        end

        integer line = GetCaretLine()
        Action closest = FindNextAction(line)
        
        if closest not= undefined and closest:GetLineNumber() < GetLineCount()
            NavigateTo(closest:GetLineNumber())
        end
    end

    private action FindPreviousAction(integer line) returns Action
        Action closest = undefined
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if act:GetLineNumber() < line and closest = undefined//it's up
                closest = act
            elseif act:GetLineNumber() < line and closest not= undefined//it's up
                if line - act:GetLineNumber() < line - closest:GetLineNumber()
                    closest = act
                end
            end
        end
        return closest
    end

    private action FindNextAction(integer line) returns Action
        Action closest = undefined
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if act:GetLineNumber() - 1 > line and closest = undefined//it's up
                closest = act
            elseif act:GetLineNumber() - 1 > line and closest not= undefined//it's up
                if line - act:GetLineNumber()  - 1 > line - closest:GetLineNumber()
                    closest = act
                end
            end
        end
        return closest
    end

    private action FindAction(integer line) returns Action
        if clazz = undefined
            return undefined
        end
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if line >= act:GetLineNumber() - 1 and line <= act:GetLineNumberEnd()
                return act
            end
        end
        return undefined
    end

    private action FindLastBlockInAction(Action act) returns Block
        if act = undefined
            return undefined
        end
        Block value = act:GetBlock()
        if value = undefined
            return undefined
        end

        if value:GetSubBlockSize() = 0
            return undefined
        end

        return value:GetBlock(value:GetSubBlockSize() - 1)
    end

    private action FindFirstBlockInAction(Action act) returns Block
        if act = undefined
            return undefined
        end
        Block value = act:GetBlock()
        if value = undefined
            return undefined
        end

        if value:GetSubBlockSize() = 0
            return undefined
        end

        return value:GetBlock(0)
    end

    private action ComputeBlockRange(Block block) returns integer
         return block:GetLineNumberEnd() - block:GetLineNumber()   
    end

    private action FindLowestSubblock(Action act, Block block, integer line) returns Block
        Block candidate = undefined
        if block not= undefined
            Iterator<Block> blocks = block:GetBlocks()
            repeat while blocks:HasNext()
                Block sub = blocks:Next()
                if line >= sub:GetLineNumber() - 1 and line <= sub:GetLineNumberEnd() - 1
                    Block final = FindLowestSubblock(act, sub, line)
                    Block newCandidate = undefined
                    if final not= undefined
                        newCandidate = final
                    else
                        newCandidate = sub
                    end
                    if candidate = undefined
                        candidate = sub
                    else
                        if sub:GetLineNumber() - 1 = line
                            candidate = sub
                        elseif ComputeBlockRange(sub) < ComputeBlockRange(candidate)
                            candidate = sub
                        end
                    end
                end
            end
        end
        return candidate
    end

    private action NavigateTo(integer line)
        SetCaretPositionToLine(line - 1)
        GoToLine(line - 1)
    end

    private action NavigateToIndex(integer index)
        SetCaretPosition(index)
        integer line = GetCaretLine()
        GoToLine(line)
    end

    action FindTokenIndexFromCaret(integer index) returns integer
        if lexer = undefined or lexer:IsEmpty()
            return -1
        end

        if index < lexer:Get(0):GetStartIndex()
            return 0
        end

        if index > lexer:Get(lexer:GetSize() - 1):GetStopIndex()
            return lexer:GetSize() - 1
        end

        integer high = lexer:GetSize()
        integer low = 0
        integer mid = lexer:GetSize() / 2
        i = mid
        
        continue = true
        repeat while continue
            Token token = lexer:Get(mid)
            Token next = undefined

            if mid + 1 < lexer:GetSize()
                next = lexer:Get(mid + 1)
            else
                return lexer:GetSize() - 1 
            end

            //we found the token
            if index >= token:GetStartIndex() and index < next:GetStartIndex()
                return mid
            elseif index >= token:GetStopIndex()
                low = mid
                mid = ((high - low) / 2) + mid
                i = mid
            else
                high = mid
                mid = ((high - low) / 2) + low
                i = mid
            end
        end
        return -1
    end

    private action IsSignificantToken(Token token) returns boolean
        if token:GetTokenCategory() = categories:IF or
            token:GetTokenCategory() = categories:ELSE_IF or
            token:GetTokenCategory() = categories:ELSE or
            token:GetTokenCategory() = categories:REPEAT or
            token:GetTokenCategory() = categories:END or
            token:GetTokenCategory() = categories:ACTION or
            token:GetTokenCategory() = categories:CLASS or
            token:GetTokenCategory() = categories:COMMENTS or
            token:GetTokenCategory() = categories:CHECK or
            token:GetTokenCategory() = categories:DETECT or
            token:GetTokenCategory() = categories:ON or
            token:GetTokenCategory() = categories:ALWAYS
            return true
        end

        return false
    end

    action SmartNavigateLeft
        integer caret = GetCaretLine()
        integer index = GetCaretPosition()
        if lexer = undefined
            return now
        end

        integer tokenIndex = FindTokenIndexFromCaret(index)
        if tokenIndex = -1
            return now
        end

        if tokenIndex > lexer:GetSize()
            return now
        end

        Token token = lexer:Get(tokenIndex)
        i = tokenIndex - 1
        repeat while i >= 0
            Token previous = lexer:Get(i)
            if IsSignificantToken(previous)
                NavigateToIndex(previous:GetStartIndex())
                return now
            end
            i = i - 1
        end
    end

    action SmartNavigateRight
        integer caret = GetCaretLine()
        integer index = GetCaretPosition()
        if lexer = undefined
            return now
        end

        integer tokenIndex = FindTokenIndexFromCaret(index)
        if tokenIndex = -1
            return now
        end

        integer size = lexer:GetSize()
        if tokenIndex >= size
            return now
        end

        Token token = lexer:Get(tokenIndex)
        i = tokenIndex + 1
        repeat while i < size
            Token next = lexer:Get(i)
            if IsSignificantToken(next)
                NavigateToIndex(next:GetStartIndex())
                return now
            end
            i = i + 1
        end
    end

    action FindNextBlock(Block block) returns Block
        Block mom = block:GetParentBlock()
        if mom = undefined //there is no
            return undefined
        end
        
        //search through the sequence and find this block. 
        //then grab the next one. If there isn't one, then return nothing
        i = 0
        Iterator<Block> iterator = mom:GetBlocks()
        repeat while iterator:HasNext()
            Block momBlock = iterator:Next()
            if momBlock = block
                if i + 1 < mom:GetSubBlockSize()
                    return mom:GetBlock(i + 1)
                end
            end
            i = i + 1
        end

        //if it's still undefined, try the mom of this one
        //eventually this will recurse out, because parents will eventually be null
        return FindNextBlock(mom)
    end

    action FindPreviousBlock(Block block) returns Block
        Block mom = block:GetParentBlock()
        if mom = undefined //there is no
            return undefined
        end
        
        //search through the sequence and find this block. 
        //then grab the next one. If there isn't one, then return nothing
        i = 0
        Iterator<Block> iterator = mom:GetBlocks()
        repeat while iterator:HasNext()
            Block momBlock = iterator:Next()
            if momBlock = block
                if i - 1 >= 0 and i - 1 < mom:GetSubBlockSize()
                    return mom:GetBlock(i - 1)
                end
            end
            i = i + 1
        end

        //if it's still undefined, try the mom of this one
        //eventually this will recurse out, because parents will eventually be null
        return FindPreviousBlock(mom)
    end

    action GetDefaultFont returns Font
        Font font
        font:SetSize(GetDefaultFontSize())
        File file
        file:SetPath("Resources/Fonts/FiraCode-Retina.ttf")
        font:LoadFont(file)
        return font
    end
end