package Libraries.Development.Environment.Studio.Interface

use Libraries.Interface.Controls.TextBox
use Libraries.Language.Compile.Symbol.SymbolTable
use Libraries.Development.Environment.Studio.Build.BuildManager
use Libraries.Language.Compile.Symbol.Class
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Symbol.Action
use Libraries.Language.Compile.Symbol.Block
use Libraries.Interface.Events.SelectionListener
use Libraries.Game.GameStateManager
use Libraries.Game.Game
use Libraries.Interface.Events.SelectionEvent
use Libraries.Game.Graphics.Color
use Libraries.Interface.Controls.TextStyles.ColoredHighlight
use Libraries.Interface.Controls.TextStyles.TextStyle
use Libraries.Language.Debug.BreakpointListener
use Libraries.Language.Debug.BreakpointEvent
use Libraries.Language.Debug.Breakpoint
use Libraries.Language.Compile.Lexer
use Libraries.Containers.Array
use Libraries.Language.Compile.Token
use Libraries.Containers.MultipleLineText
use Libraries.Interface.Controls.LineNumberGutter
use Libraries.Game.Graphics.Font
use Libraries.System.File
use Libraries.Interface.Events.GutterListener
use Libraries.Interface.Events.GutterEvent
use Libraries.Interface.Controls.TextStyles.TextStyle
use Libraries.Containers.Support.Pair
use Libraries.Development.Environment.Studio.Behaviors.PreviousBehavior
use Libraries.Development.Environment.Studio.Behaviors.NextBehavior
use Libraries.Interface.Controls.Button
use Libraries.Interface.Events.KeyboardEvent
use Libraries.Game.InputTable
use Libraries.Game.InputSet
use Libraries.Development.Environment.Studio.QuorumStudio
use Libraries.Interface.Selections.TextBoxSelection
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.Hints.Hint
use Libraries.Interface.Controls.PopupMenu
use Libraries.Interface.Controls.MenuItem
use Libraries.Interface.Undo.TextBoxEdit
use Libraries.Interface.Undo.TextBoxEditState
use Libraries.Interface.Events.TextChangeEvent
use Libraries.Interface.Controls.IndentationStrategy
use Libraries.Interface.Events.FocusEvent
use Libraries.Development.Environment.Studio.StudioFocusManager
use Libraries.Development.Environment.Projects.ProjectManager
use Libraries.Development.Environment.Projects.Project
use Libraries.Language.Compile.CompilerResult
use Libraries.Language.Compile.Symbol.Variable
use Libraries.Language.Compile.Location
use Libraries.Language.Compile.Symbol.Type
use Libraries.Development.Environment.Studio.CodeEditorTabPane
use Libraries.Language.Compile.Symbol.ActionCallResolution
use Libraries.Language.Compile.QualifiedName
use Libraries.Interface.AccessibilityManager
use Libraries.Interface.Controls.Tab

class CodeTextBox is TextBox, SelectionListener, BreakpointListener, GutterListener
    public constant text CODE_BOX_INPUT_GROUP = "Code Box Input Group"
    BuildManager manager = undefined
    GameStateManager gameStateManager
    text staticKey = ""
    Class clazz = undefined
    public constant text CARET_STYLE = "Caret"
    Color caretColor
    Color breakpointColor
    Array<Token> lexer = undefined
    Lexer categories
    LineNumberGutter gutter
    EditorTab tab = undefined

    Array<text> findReplaceNames
    Array<TextStyle> findReplaceStyles
    Array<Pair<integer>> findIndices
    Array<Pair<integer>> removeIndices
    text findWord = ""
    text replaceWord = ""
    boolean findIsWholeWord = false
    boolean findIsMatchCase = false
    boolean dialogIsOpen = false
    integer findSelection = -1
    PreviousBehavior previousBehavior
    NextBehavior nextBehavior
    FindDialog findDialog = undefined
    CompilerErrorManager errors = undefined

    on create
        Game game = gameStateManager:GetGame()
        game:AddSelectionListener(me)
        caretColor:SetColor(233.0/255.0, 239.0/255.0, 248.0/255.0, 1.0)
        breakpointColor:SetColor(252.0/255.0, 157.0/255.0, 159.0/255.0, 1.0)
        Add(gutter)
        gutter:AddGutterListener(me)
        SetPopupMenu(GeneratePopupMenu())
        SetMoveFocusOnTab(false)
    end

    private action GeneratePopupMenu returns PopupMenu
        CodeTextBoxPopupMenu menu
        menu:SetCodeTextBox(me)
        

        return menu
    end

    action GetCompilerErrorManager returns CompilerErrorManager
        return errors
    end

    action SetCompilerErrorManager(CompilerErrorManager manager)
        errors = manager
    end

    action GutterClicked(GutterEvent event)
        integer line = event:GetLine()
        if line >= GetLineCount()
            return now
        end
        if clazz not= undefined
            File file = clazz:GetFile()
            manager:ToggleBreakpoint(file, line)
        end
    end

    action SelectionChanged(SelectionEvent selection)
        Item item = selection:GetItem()
        if item:GetHashCode() = me:GetHashCode()
            integer caret = GetCaretPosition()
            boolean value1 = RemoveTextStyle(CARET_STYLE)

            boolean hasBreakpoint = HasTextStyle("Breakpoint" + GetCaretLine())
            boolean hasDebuggerLine = HasTextStyle("Debugger")
            if not hasBreakpoint and not hasDebuggerLine
                ColoredHighlight caretHighlight
                caretHighlight:SetColor(caretColor)
                caretHighlight:SetLineHighlight(true)
                TextStyle caretStyle
                caretStyle:SetIndex(caret)
                caretStyle:SetHighlight(caretHighlight)
                AddTextStyle(CARET_STYLE, caretStyle)
            end
        end
    end

    action ToggledBreakpoint(BreakpointEvent event)
        Breakpoint bp = event:GetBreakpoint()
        if bp:GetFile():GetAbsolutePath() not= GetFile():GetAbsolutePath()
            return now
        end
        if event:IsAdded()
            integer line = bp:GetLine()
            ColoredHighlight breakpointHighlight
            breakpointHighlight:SetColor(breakpointColor)
            breakpointHighlight:SetLineHighlight(true)
            TextStyle breakpointStyle
            breakpointStyle:SetIndex(GetIndexOfLine(line))
            breakpointStyle:SetHighlight(breakpointHighlight)
            AddTextStyle("Breakpoint" + bp:GetLine(), breakpointStyle)
        else
            integer line = bp:GetLine()
            RemoveTextStyle("Breakpoint" + bp:GetLine())
        end
    end

    action GetBuildManager returns BuildManager
        return manager
    end

    action SetBuildManager(BuildManager manager)
        me:manager = manager
        manager:Add(me)
    end

    action GetStaticKey returns text
        return staticKey
    end

    action SetStaticKey(text key)
        me:staticKey = key
    end

    action GetClass returns Class
        return clazz
    end

    action SetClass(Class clazz)
        me:clazz = clazz
    end

    action GetLexer returns Array<Token>
        return lexer
    end

    action SetLexer(Array<Token> lexer)
        me:lexer = lexer
    end

    action GetEditorTab returns EditorTab
        return tab
    end

    action SetEditorTab(EditorTab tab)
        me:tab = tab
    end

    action HasHints returns boolean
        if GetFile() not= undefined and errors not= undefined
            text path = GetFile():GetAbsolutePath()
            return errors:HintsAtKey(path)
        end
        return false
    end

    action GetHintsAtLine(integer line) returns Iterator<Hint>
        if GetFile() not= undefined and errors not= undefined
            text path = GetFile():GetAbsolutePath()
            Array<Hint> newHints
            Iterator<Hint> hints = errors:GetHintsAtKey(path)
            repeat while hints not= undefined and hints:HasNext()
                Hint hint = hints:Next()
                if hint:GetLineNumber() - 1 = line
                    newHints:Add(hint)
                end
            end
            return newHints:GetIterator()
        end
        return undefined
    end

    action NavigateToDeclaration
        if GetFile() not= undefined and errors not= undefined
            File file = GetFile()
            QuorumStudio studio = cast(QuorumStudio, gameStateManager:GetGame())
            StudioFocusManager focusManager = studio:GetStudioFocusManager()
            ProjectManager projectManager = studio:GetProjectManager()
            Project project = projectManager:IsProjectSourceFile(file)
            if project not= undefined
                CompilerResult result = manager:GetRecentCompilerResult(project:GetLocation():GetAbsolutePath())
                if result not= undefined
                    ActuallyNavigateToDeclaration(result, file)
                end
            end
            
        end
    end
    private action ActuallyNavigateToDeclaration(CompilerResult result, File file)
        SymbolTable table = result:symbolTable
        QuorumStudio qs = cast(QuorumStudio, gameStateManager:GetGame())
        CodeEditorTabPane pane = qs:GetTabPane()

        if table not= undefined
            Class clazz = table:GetClassInFile(file:GetAbsolutePath())
            if clazz = undefined
                return now
            end
            integer position = GetCaretPosition()
            Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
            repeat while parents:HasNext()
                QualifiedName momName = parents:Next()
                if momName not= undefined and IsInLocation(position, momName)
                    Class mom = clazz:GetValidUseName(momName:GetName())
                    if mom not= undefined
                        JumpToClass(mom, 0, 0, pane)
                        return now
                    end
                end
            end


            Iterator<Action> actions = clazz:GetActions()
            repeat while actions:HasNext()
                Action act = actions:Next()
                Type returnType = act:GetReturnType()
                if returnType not= undefined and not returnType:IsVoid()
                    if IsInLocation(position, act:GetReturnLocation())
                        text key = returnType:GetStaticKey()
                        Class jumpToClass = table:GetClass(key)
                        if jumpToClass not= undefined
                            JumpToClass(jumpToClass, 0, 0, pane)
                            return now
                        end
                    end
                end

                if IsInLocation(position, act)
                    //check for variables
                    Iterator<Variable> parameters = act:GetParameterIterator()
                    if CheckForJump(parameters, table)
                        return now
                    end

                    Iterator<Variable> variables = act:GetAllLocalVariables()
                    if CheckForJump(variables, table)
                        return now
                    end
                end

                Iterator<ActionCallResolution> calls = act:GetActionCalls()
                repeat while calls:HasNext()
                    ActionCallResolution call = calls:Next()
                    if IsInLocation(position, call:location)
                        Class parentClass = call:resolvedAction:GetParentClass()
                        if parentClass not= undefined
                            JumpToClass(parentClass, call:resolvedAction:GetIndex(), call:resolvedAction:GetLineNumber(), pane)
                        end
                    end
                end
            end
        end
    end

    private action JumpToClass(Class clazz, integer position, integer line, CodeEditorTabPane pane)
        File jumpFile = clazz:GetFile()
        Tab tab1 = pane:OpenNewTab(jumpFile)
        if not (tab1 is EditorTab)
            return now
        end
        EditorTab tab = cast(EditorTab, tab1)
        pane:Select(tab)
        CodeTextBox box = tab:GetTextBox()
        if box not= undefined
            box:SetCaretPosition(position)
            box:GoToLine(line)
        end
    end

    private action CheckForJump(Iterator<Variable> variables, SymbolTable table) returns boolean
        QuorumStudio qs = cast(QuorumStudio, gameStateManager:GetGame())
        CodeEditorTabPane pane = qs:GetTabPane()

        integer position = GetCaretPosition()
        repeat while variables:HasNext()
            Variable var = variables:Next()
            Location location = var:GetTypeLocation()
            if IsInLocation(position, location) 
                //found the variable's type
                Type type = var:GetType()
                text key = type:GetStaticKey()
                Class jumpToClass = table:GetClass(key)
                if jumpToClass not= undefined
                    JumpToClass(jumpToClass, 0, 0, pane)
                    return true
                else 
                    return false
                end
            end
        end

        //perhaps it is a use for a variable.
        variables:Rewind()
        repeat while variables:HasNext()
            Variable var = variables:Next()
            Iterator<Location> locations = var:GetUseLocations()
            repeat while locations:HasNext()
                Location location = locations:Next()
                if IsInLocation(position, location) 
                    Location loc = var:GetTypeLocation()
                    SetCaretPosition(loc:GetIndex())
                    GoToLine(loc:GetLineNumber())
                    return true
                end
            end
        end
        return false
    end

    private action IsInLocation(integer position, Location location) returns boolean
        if location not= undefined and position >= location:GetIndex() and position < location:GetIndexEnd() + 1
            return true
        end
        return false
    end

    /*
        If there exists a hint at this line, return the top one. If not, then
        return undefined.
    */
    action GetTopHintAtLine(integer line) returns Hint
        Iterator<Hint> iterator = GetHintsAtLine(line)
        repeat while iterator:HasNext()
            Hint hint = iterator:Next()
            return hint
        end
        return undefined
    end

    action GetFile returns File
        EditorTab tab = GetEditorTab()
        if tab = undefined
            return undefined
        end
        return tab:GetFile()
    end

    /*
        This action overrides the default TextBox AddIndentation to account for 
        selecting multiple lines. Assumes that the code text box will not move on tab
    */
    action AddIndentation
        if GetSelection():IsEmpty()
            parent:TextBox:AddIndentation()
        else
            //if there is a selection it wont replace the selection
            //instead it will indent the selected lines 
            GetTextBoxEditManager():SetSpecialAction(true)
            AddMultipleIndentation()
            GetTextBoxEditManager():SetSpecialAction(false)
        end
    end

    private action AddMultipleIndentation
        //Get information from the selection to form a new one after
        integer index = GetSelection():GetFirstLine()
        integer stop = GetSelection():GetLastLine()
        integer newSelectStart = GetSelection():GetStartIndex()
        integer newSelectEnd = GetSelection():GetEndIndex() + GetIndentationStrategy():GetSize() * (stop - index + 1)
        integer newCaretPos = GetCaretPosition()

        if newCaretPos not= GetIndexOfLine(GetCaretLine())
            newCaretPos = newCaretPos + GetIndentationStrategy():GetSize()
            newSelectStart = newSelectStart + GetIndentationStrategy():GetSize()
        end

        //empty the selection so the inserts can happen properly
        EmptySelectionEvent(false)
        repeat while index <= stop
            parent:TextBox:AddIndentation(GetIndexOfLine(index))
            index = index + 1
        end
        
        //update the caret and update to new selection
        SetCaretPosition(newCaretPos)
        Select(newSelectStart , newSelectEnd, false)
    end

    action SmartNavigateUp
        if clazz = undefined
            return now
        end

        integer line = GetCaretLine()
        Action closest = FindPreviousAction(line)

        if closest not= undefined and closest:GetLineNumber() > 0
            NavigateTo(closest:GetLineNumber())
        end

        AnnounceCurrentLine()
    end

    action SelectSmartNavigateUp        
        if clazz = undefined
            return now
        end

        TextBoxSelection selection = GetSelection() //gets the current caret position
        integer startIndex = selection:GetStartIndex()
        integer startIndexLine = GetLineIndexOfCharacter(startIndex)
        integer endIndex = selection:GetEndIndex()
        
        integer line = GetCaretLine()
        Action closest = FindPreviousAction(line)
        
        if closest not= undefined and closest:GetLineNumber() > 0
            NavigateTo(closest:GetLineNumber())
        end

        integer previousActionIndex = GetCaretPosition()
        //there is no previous action, if there is an existing selection prior to the first action then it should be cleared so that there is no selection
        if closest = undefined and previousActionIndex >= endIndex     
            NavigateTo(GetLineIndexOfCharacter(startIndex))
            Select(startIndex, startIndex, true)
        //we are adding to the selection or there are no more actions to select so we want to maintain our current selection
        elseif ((previousActionIndex < startIndex) or (closest = undefined and  previousActionIndex < endIndex)) 
            Select(previousActionIndex, endIndex, false)
        else        //we are removing from the current selection
            Select(startIndex, previousActionIndex, true)
        
        end

    end

    action SmartNavigateDown
        if clazz = undefined
            return now
        end

        
        integer line = GetCaretLine()
        Action closest = FindNextAction(line)
 
        if closest not= undefined and closest:GetLineNumber() < GetLineCount()
            NavigateTo(closest:GetLineNumber())
        end

        AnnounceCurrentLine()
    end

    action SelectSmartNavigateDown
        if clazz = undefined
            return now
        end
        
        TextBoxSelection selection = GetSelection()
        integer startIndex = selection:GetStartIndex()
        integer endIndex = selection:GetEndIndex()
        integer caretPosition = GetCaretPosition()

        integer line = GetCaretLine()
        Action nextAction = FindNextAction(line)
        Action thisAction = FindAction(line)
        Action previousAction = FindPreviousAction(line)

        if thisAction not= undefined
            integer thisActionStartIndex = GetIndexOfLine(thisAction:GetLineNumber())
            integer thisActionEndIndex = GetIndexOfLine(thisAction:GetLineNumberEnd())
        end
        Action closest = FindNextAction(line)
        
        //There is another action so we will highlight up to the next action
        if nextAction not= undefined and nextAction:GetLineNumber() < GetLineCount()
            NavigateTo(nextAction:GetLineNumber())
        //there is not another action, so select to this action's end + 1
        elseif nextAction = undefined 
            NavigateTo(thisAction:GetLineNumberEnd() + 1)
        end
        
        integer nextActionIndex = GetCaretPosition()

        //we are at the last action in the textbox, maintain our current selection
        if ((endIndex = nextActionIndex) and (nextAction = undefined)) 
            Select(startIndex, nextActionIndex, true)
        //there is another action to select beneath this one and we are extending the current selection
        elseif(endIndex < nextActionIndex and caretPosition < endIndex)
            Select(endIndex, nextActionIndex, true)
        elseif endIndex < nextActionIndex or startIndex = endIndex 
            Select(startIndex, nextActionIndex, true)
        elseif nextActionIndex < endIndex
            Select(nextActionIndex, endIndex, false)
        end
    end

    // Used to announce the current line. Useful after moving the caret to an
    // arbitrary line, e.g. using smart navigation or go to.
    private action AnnounceCurrentLine
        AccessibilityManager accessibility = gameStateManager:GetAccessibilityManager()
        if accessibility not= undefined
            accessibility:Notify(me, GetCurrentLineText(), accessibility:OTHER_NOTIFICATION)
        end
    end

    private action FindPreviousAction(integer line) returns Action
        Action closest = undefined
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if act:GetLineNumber() < line and closest = undefined//it's up
                closest = act
            elseif act:GetLineNumber() < line and closest not= undefined//it's up
                if line - act:GetLineNumber() < line - closest:GetLineNumber()
                    closest = act
                end
            end
        end
        return closest
    end

    private action FindNextAction(integer line) returns Action
        Action closest = undefined
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if act:GetLineNumber() - 1 > line and closest = undefined//it's up
                closest = act
            elseif act:GetLineNumber() - 1 > line and closest not= undefined//it's up
                if line - act:GetLineNumber()  - 1 > line - closest:GetLineNumber()
                    closest = act
                end
            end
        end
        return closest
    end

    private action FindAction(integer line) returns Action
        if clazz = undefined
            return undefined
        end
        Iterator<Action> iterator = clazz:GetActions()
        repeat while iterator:HasNext()
            Action act = iterator:Next()
            if line >= act:GetLineNumber() - 1 and line <= act:GetLineNumberEnd()
                return act
            end
        end
        return undefined
    end

    private action FindLastBlockInAction(Action act) returns Block
        if act = undefined
            return undefined
        end
        Block value = act:GetBlock()
        if value = undefined
            return undefined
        end

        if value:GetSubBlockSize() = 0
            return undefined
        end

        return value:GetBlock(value:GetSubBlockSize() - 1)
    end

    private action FindFirstBlockInAction(Action act) returns Block
        if act = undefined
            return undefined
        end
        Block value = act:GetBlock()
        if value = undefined
            return undefined
        end

        if value:GetSubBlockSize() = 0
            return undefined
        end

        return value:GetBlock(0)
    end

    private action ComputeBlockRange(Block block) returns integer
         return block:GetLineNumberEnd() - block:GetLineNumber()   
    end

    private action FindLowestSubblock(Action act, Block block, integer line) returns Block
        Block candidate = undefined
        if block not= undefined
            Iterator<Block> blocks = block:GetBlocks()
            repeat while blocks:HasNext()
                Block sub = blocks:Next()
                if line >= sub:GetLineNumber() - 1 and line <= sub:GetLineNumberEnd() - 1
                    Block final = FindLowestSubblock(act, sub, line)
                    Block newCandidate = undefined
                    if final not= undefined
                        newCandidate = final
                    else
                        newCandidate = sub
                    end
                    if candidate = undefined
                        candidate = sub
                    else
                        if sub:GetLineNumber() - 1 = line
                            candidate = sub
                        elseif ComputeBlockRange(sub) < ComputeBlockRange(candidate)
                            candidate = sub
                        end
                    end
                end
            end
        end
        return candidate
    end

    private action NavigateTo(integer line)
        SetCaretPositionToLine(line - 1)
        GoToLine(line - 1)
    end

    private action NavigateToIndex(integer index)
        SetCaretPosition(index)
        integer line = GetCaretLine()
        GoToLine(line)
    end

    action FindTokenIndexFromCaret(integer index) returns integer
        if lexer = undefined or lexer:IsEmpty()
            return -1
        end

        if index < lexer:Get(0):GetStartIndex()
            return 0
        end

        if index > lexer:Get(lexer:GetSize() - 1):GetStopIndex()
            return lexer:GetSize() - 1
        end

        integer high = lexer:GetSize()
        integer low = 0
        integer mid = lexer:GetSize() / 2
        i = mid
        
        continue = true
        repeat while continue
            Token token = lexer:Get(mid)
            Token next = undefined

            if mid + 1 < lexer:GetSize()
                next = lexer:Get(mid + 1)
            else
                return lexer:GetSize() - 1 
            end

            //we found the token
            if index >= token:GetStartIndex() and index < next:GetStartIndex()
                return mid
            elseif index >= token:GetStopIndex()
                low = mid
                mid = ((high - low) / 2) + mid
                i = mid
            else
                high = mid
                mid = ((high - low) / 2) + low
                i = mid
            end
        end
        return -1
    end

    private action IsSignificantToken(Token token) returns boolean
        if token:GetTokenCategory() = categories:IF or
            token:GetTokenCategory() = categories:ELSE_IF or
            token:GetTokenCategory() = categories:ELSE or
            token:GetTokenCategory() = categories:REPEAT or
            token:GetTokenCategory() = categories:END or
            token:GetTokenCategory() = categories:ACTION or
            token:GetTokenCategory() = categories:CLASS or
            token:GetTokenCategory() = categories:COMMENTS or
            token:GetTokenCategory() = categories:CHECK or
            token:GetTokenCategory() = categories:DETECT or
            token:GetTokenCategory() = categories:ON or
            token:GetTokenCategory() = categories:ALWAYS
            return true
        end

        return false
    end

    action SmartNavigateLeft
        integer caret = GetCaretLine()
        integer index = GetCaretPosition()
        if lexer = undefined
            return now
        end

        integer tokenIndex = FindTokenIndexFromCaret(index)
        if tokenIndex = -1
            return now
        end

        if tokenIndex > lexer:GetSize()
            return now
        end

        Token token = lexer:Get(tokenIndex)
        i = tokenIndex - 1
        repeat while i >= 0
            Token previous = lexer:Get(i)
            if IsSignificantToken(previous)
                NavigateToIndex(previous:GetStartIndex())
                AnnounceCurrentLine()
                return now
            end
            i = i - 1
        end

        AnnounceCurrentLine()
    end

    action SmartNavigateRight
        integer caret = GetCaretLine()
        integer index = GetCaretPosition()
        if lexer = undefined
            return now
        end

        integer tokenIndex = FindTokenIndexFromCaret(index)
        if tokenIndex = -1
            return now
        end

        integer size = lexer:GetSize()
        if tokenIndex >= size
            return now
        end

        Token token = lexer:Get(tokenIndex)
        i = tokenIndex + 1
        repeat while i < size
            Token next = lexer:Get(i)
            if IsSignificantToken(next)
                NavigateToIndex(next:GetStartIndex())
                AnnounceCurrentLine()
                return now
            end
            i = i + 1
        end

        AnnounceCurrentLine()
    end

    action FindNextBlock(Block block) returns Block
        Block mom = block:GetParentBlock()
        if mom = undefined //there is no
            return undefined
        end
        
        //search through the sequence and find this block. 
        //then grab the next one. If there isn't one, then return nothing
        i = 0
        Iterator<Block> iterator = mom:GetBlocks()
        repeat while iterator:HasNext()
            Block momBlock = iterator:Next()
            if momBlock = block
                if i + 1 < mom:GetSubBlockSize()
                    return mom:GetBlock(i + 1)
                end
            end
            i = i + 1
        end

        //if it's still undefined, try the mom of this one
        //eventually this will recurse out, because parents will eventually be null
        return FindNextBlock(mom)
    end

    action FindPreviousBlock(Block block) returns Block
        Block mom = block:GetParentBlock()
        if mom = undefined //there is no
            return undefined
        end
        
        //search through the sequence and find this block. 
        //then grab the next one. If there isn't one, then return nothing
        i = 0
        Iterator<Block> iterator = mom:GetBlocks()
        repeat while iterator:HasNext()
            Block momBlock = iterator:Next()
            if momBlock = block
                if i - 1 >= 0 and i - 1 < mom:GetSubBlockSize()
                    return mom:GetBlock(i - 1)
                end
            end
            i = i + 1
        end

        //if it's still undefined, try the mom of this one
        //eventually this will recurse out, because parents will eventually be null
        return FindPreviousBlock(mom)
    end

    action GetDefaultFont returns Font
        Font font
        font:SetSize(GetDefaultFontSize())
        File file
        file:SetPath("Resources/Fonts/FiraCode-Retina.ttf")
        font:LoadFont(file)
        return font
    end

    /*
    An action used to allow Find/Replace highlighting to be specifically marked
    in the TextBox so we can restore it later if the highlights are all blown
    away (e.g. by the UpdateCodeEditorBehavior).
    */
    action AddFindReplaceStyle(text name, TextStyle style)
        findReplaceNames:Add(name)
        findReplaceStyles:Add(style)
        AddTextStyle(name, style)
    end

    action RemoveFindReplaceStyle(text name)
        RemoveTextStyle(name)
    end

    /*
    An action used to allow Find/Replace highlighting to be specifically marked
    in the TextBox so we can restore it later if the highlights are all blown
    away (e.g. by the UpdateCodeEditorBehavior).
    */
    action RestoreFindReplaceStyles
        integer counter = 0
        repeat while counter < findReplaceStyles:GetSize()
            AddTextStyle(findReplaceNames:Get(counter), findReplaceStyles:Get(counter))
            counter = counter + 1
        end
    end

    action RemoveFindReplaceStyles()
        integer counter = 0
        repeat while counter < findReplaceStyles:GetSize()
            RemoveTextStyle(findReplaceNames:Get(counter))
            counter = counter + 1
        end
        EmptyFindReplaceStyles()
    end

    /*
    Empties the arrays for the Find/Replace highlighting so they can no longer
    be restored by the TextBox.
    */
    action EmptyFindReplaceStyles
        findReplaceNames:Empty()
        findReplaceStyles:Empty()
    end

    action SetIsDialogOpen(boolean state)
        dialogIsOpen = state
    end
    
    action GetIsDialogOpen returns boolean
        return dialogIsOpen
    end

    action FindText(text find, boolean wholeWord, boolean matchCase) 
        findWord = find
        text textValue = GetText() //+ bufferSpace
        //if there is a current selection then it needs to be removed
        if findSelection >= 0
            RemoveCurrentSelection()
        end
        integer findIndex = 0
        integer findSize = find:GetSize()       //size of the word we are searching for
        integer endIndex = textValue:GetSize()
                
        removeIndices = findIndices:CopyToArray()       //remove any previously highlighted instances of find 
        findIndices:Empty()

        if removeIndices:GetSize() not= 0 
            RemoveSelections()
        end
        if find not= ""
            if textValue:GetSize() not= 0
                repeat while (findIndex >= 0) and ((findIndex + findSize) < endIndex + 1)   //start from beginning of text and go through til the end
                    Pair<integer> indices
                    if find:EqualsIgnoringCase(textValue:GetSubtext(findIndex, (findIndex + findSize)))
                        indices:Set(findIndex, (findIndex + (findSize - 1)))
                        findIndices:Add(indices)
                        findIndex = findIndex + findSize
                    else
                        findIndex = findIndex + 1
                    end
                end
            end

            if matchCase
                findIsMatchCase = true
                MatchCaseFindText(find)
            else
                findIsMatchCase = false
            end

            if wholeWord
                findIsWholeWord = true
                WholeWordFindText(find)
            else
                findIsWholeWord = false
            end

            if dialogIsOpen
                UpdateSelections()
            end
            SetSelection()
        end            
    end

    /* Called by FindText()
    Sets the current selection to the findIndices starting index that is after 
    the caret position in the textbox. Calls UpdateCurrentSelection to highlight
    this selection in the textbox */
    private action SetSelection()
        if findIndices:GetSize() not= 0 
            if findSelection < 0
            integer caretIndex = GetCaretPosition()
            integer startIndex = 0
            integer arrayIndex = 0
            if caretIndex = 0
                findSelection = 0
            else
                repeat while startIndex < caretIndex and arrayIndex < findIndices:GetSize()
                    startIndex = findIndices:Get(arrayIndex):GetFirstValue()
                    arrayIndex = arrayIndex + 1
                end
                findSelection = (arrayIndex - 1)
                end
            end
            UpdateCurrentSelection(-1, false)            
        end
    end

    /* Called by FindText() and passed the find text from the dialog.
    If there are any instances of find that do not meet the MatchCase criteria 
    then the Pair<startIndex, endIndex> are added to the removeIndices array */
    private action MatchCaseFindText(text find)
        text subtext = ""
        integer startIndex = 0
        integer endIndex = 0
        text textValue = GetText()
        
        integer i = 0
        repeat while i < findIndices:GetSize()
            startIndex = findIndices:Get(i):GetFirstValue()
            endIndex = findIndices:Get(i):GetSecondValue()
            subtext = textValue:GetSubtext(startIndex, (endIndex + 1))
            if not find:Equals(subtext)
                removeIndices:Add(findIndices:Get(i))
            end
            i = i + 1
        end
    end

    /* Called by FindText() and passed the find text from the dialog.
    If there are any instances of find that do not meet the WholeWord criteria 
    then the Pair<startIndex, endIndex> are added to the removeIndices array */
    private action WholeWordFindText(text find)
        text break = "
"
        integer startIndex = 0
        integer endIndex = 0
        integer previousIndex = 0
        integer nextIndex = 0
        text previousCharacter = ""
        text nextCharacter = ""
        text textValue = GetText()

        integer i = 0
        repeat while i < findIndices:GetSize()
            startIndex = findIndices:Get(i):GetFirstValue()
            endIndex = findIndices:Get(i):GetSecondValue()
            previousIndex = startIndex - 1
            nextIndex = endIndex + 1
            if previousIndex < 0
                previousCharacter = " "
            else
                previousCharacter = textValue:GetCharacter(previousIndex)
            end
            if nextIndex > textValue:GetSize() - 1
                nextCharacter = " "
            else
                nextCharacter = textValue:GetCharacter(nextIndex)
            end

            if not((previousCharacter = " ") or (previousCharacter = ".") or (previousCharacter = "/")
            or (previousCharacter = "*") or (previousCharacter = "(") or (previousCharacter = ")") or (previousCharacter = "+") 
            or (previousCharacter = "-") or (previousCharacter = ">") or (previousCharacter = "<") or (previousCharacter = "=") 
            or (previousCharacter = break) or (previousCharacter = ","))
                removeIndices:Add(findIndices:Get(i))
            elseif not ((nextCharacter = " ") or (nextCharacter = ".") or (nextCharacter = "/") 
            or (nextCharacter = "*") or (nextCharacter = "(") or (nextCharacter = ")") or (nextCharacter = "+") 
            or (nextCharacter = "-") or (nextCharacter = ">") or (nextCharacter = "<") or (nextCharacter = "=") 
            or (nextCharacter = break) or (nextCharacter = ","))
                removeIndices:Add(findIndices:Get(i))  
            end
            i = i + 1
        end
    end

    action GetCurrentFindIndex returns integer
        return findSelection
    end

    action GetFindMatches returns integer
        return findIndices:GetSize()
    end

    action GetIsMatchCase returns boolean
        return findIsMatchCase
    end

    action GetIsWholeWord returns boolean
        return findIsWholeWord
    end

    action SetFindWord(text find)
        findWord = find
    end
    
    action GetFindWord returns text
        return findWord
    end

    action HasSelection returns boolean
        TextBoxSelection selection = GetSelection()
        if selection:GetStartIndex() = selection:GetEndIndex()
            return false
        else
            return true
        end

    end

    action GetFindSelection returns text
        TextBoxSelection selection = GetSelection()
        return selection:GetText()
    end

    action SetReplaceWord(text replace)
        replaceWord = replace
    end

    action GetReplaceWord returns text
        return replaceWord
    end


    action GetPreviousBehavior returns PreviousBehavior
        return previousBehavior
    end

    action GetNextBehavior returns NextBehavior
        return nextBehavior
    end


    action SetDialog(FindDialog dialog)
        findDialog = dialog
    end

    /* Updates the highlighted instances of "find" in the textBox
    Calls RemoveSelections() to remove the Pair<startIndex, endIndex> that no 
    longer apply due to MatchCase criteria, WholeWord criteria, or 
    TextChange events */
    private action UpdateSelections()
        ColoredHighlight highlight
        highlight:SetVisibleWhileSelected(true)
        Color color
        highlight:SetColor(color:Orange())
        integer startIndex = 0
        integer endIndex = 0

        if removeIndices:GetSize() not= 0
            RemoveSelections()
        end

        if findIndices:GetSize() not= 0
            integer i = 0
            repeat while i < findIndices:GetSize()
                TextStyle textStyle
                Pair<integer> indices
                indices = findIndices:Get(i)
                startIndex = indices:GetFirstValue()
                endIndex = indices:GetSecondValue()
                textStyle:SetIndex(startIndex)
                textStyle:SetSize((endIndex - startIndex) + 1)
                textStyle:SetHighlight(highlight)
                AddFindReplaceStyle("highlight" + startIndex, textStyle)
                i = i + 1
            end
        end
    end
    
    /* Removes the highlighted instances of "find" that are no longer applicable 
    due to MatchCase criteria, WholeWord criteria, or a TextChange event. */
    private action RemoveSelections()
        integer startIndex = 0
        integer i = 0
        repeat while i < removeIndices:GetSize()            
            startIndex = removeIndices:Get(i):GetFirstValue()                        
            findIndices:Remove(removeIndices:Get(i))
            RemoveFindReplaceStyle("highlight" + startIndex)
            i = i + 1
        end
        removeIndices:Empty() 
        RemoveFindReplaceStyles()
    end   

    /* moves the selection index to the next position and sends the 
    previousSelection index to UpdatCurrentSelection() to add the new 
    currentSelection highlight and remove the previousSelection highlight 
    from the textBox */
    action NextSelection()
        if findIndices:GetSize() not= 0
            integer previousSelection = findSelection
            findSelection = findSelection + 1
            UpdateCurrentSelection(previousSelection, true)
        end
    end

    /* moves the selection index to the previous position and sends the 
    previousSelection index to UpdatCurrentSelection() to add the new 
    currentSelection highlight and remove the previousSelection highlight 
    from the textBox */
    action PreviousSelection()
        if findIndices:GetSize() not= 0
            integer previousSelection = findSelection
            findSelection = findSelection - 1
            UpdateCurrentSelection(previousSelection, true)
        end
    end
    
    /* called by PreviousSelection(), NextSelection(), and SetSelection() to 
    update the current selection in the array of indices. Highlights the line 
    of the current selection in light blue (currently not working as expected), 
    highlights the current selection in a darker shade of blue, */
    private action UpdateCurrentSelection(integer previousSelection, boolean moveCaret)
        if findSelection < 0
            findSelection = (findIndices:GetSize() - 1)
        end
        if findSelection >= findIndices:GetSize()
            findSelection = 0
        end

        
        integer wordStartIndex =  findIndices:Get(findSelection):GetFirstValue()
        integer wordEndIndex = findIndices:Get(findSelection):GetSecondValue()        

        integer lineStartIndex = GetLineIndexOfCharacter(wordStartIndex)
        //only go to the line when using next and previous functionality
        if moveCaret
            GoToLine(lineStartIndex)
        end

        ColoredHighlight highlight
        ColoredHighlight selectionHighlight
        highlight:SetVisibleWhileSelected(true)
        selectionHighlight:SetVisibleWhileSelected(true)
        TextStyle textStyle
        TextStyle word
        Color color
        Color blue
        blue:SetColor(0, 0, 0.5, 0.2)
        highlight:SetColor(color:Orange())
        selectionHighlight:SetColor(blue)

        if previousSelection >= 0 
            integer previousStartIndex = findIndices:Get(previousSelection):GetFirstValue()
            integer previousEndIndex = findIndices:Get(previousSelection):GetSecondValue()
            integer previousLineStartIndex = GetLineIndexOfCharacter(previousStartIndex)
            textStyle:SetIndex(previousStartIndex)
            textStyle:SetSize((previousEndIndex - previousStartIndex) + 1)
            textStyle:SetHighlight(highlight)

            if dialogIsOpen
            //resets the previous selection back to the orange highlight and removes the line highlight
                if not HasTextStyle("highlight" + previousStartIndex)
                    AddFindReplaceStyle("highlight" + previousStartIndex, textStyle)
                end
            end
            if HasTextStyle("selectionHighlight" + previousStartIndex)
                RemoveFindReplaceStyle("selectionHighlight" + previousStartIndex)
            end
        end

        if dialogIsOpen
            word:SetIndex(wordStartIndex)
            word:SetSize((wordEndIndex - wordStartIndex)+ 1)
            word:SetHighlight(selectionHighlight)

            //sets the current selection to blue highlight
            RemoveFindReplaceStyle("highlight" + wordStartIndex)       //remove the orange highlight
            AddFindReplaceStyle("selectionHighlight" + wordStartIndex, word)    //add the blue highlight for current selection
        else
            SetCaretPosition(wordEndIndex + 1)
            Select(wordStartIndex, wordEndIndex + 1, true)
        end

        if findDialog not= undefined
            findDialog:UpdateMatches(findSelection, findIndices:GetSize())
        end
    end

    action DialogClosed
        RemoveFindReplaceStyles()
        if findIndices:GetSize() not= 0
            UpdateCurrentSelection(-1, false)
        end
    end

    /* removes the selection highlighting before updating the indices
    called when there is a text, matchCase, or wholeWord change and when the
    dialog is closed, to remove all highlights within the textBox */
    private action RemoveCurrentSelection
        if findIndices:GetSize() not= 0
            integer wordStartIndex = findIndices:Get(findSelection):GetFirstValue()
            RemoveFindReplaceStyle("selectionHighlight" + wordStartIndex)
            findSelection = -1   
        end
    end

    /* replaces only the current selection of find with replace, if there is no
    text in the replaceField of the dialog, then the findWOrd is replaced with a 
    blank text. */
    action Replace(text replaceWord) 
        //SetTextChangeListenerOn(false) *In the ReplaceBehavior
        me:replaceWord = replaceWord
        if findSelection < 0
            findSelection = 0
        end

        if findIndices:GetSize() not= 0
            integer startIndex = findIndices:Get(findSelection):GetFirstValue()
            integer endIndex = findIndices:Get(findSelection):GetSecondValue()
            Delete(startIndex, (endIndex + 1))
            Insert(startIndex, replaceWord)
        end
        //SetTextChangeListenerOn(true) *In the ReplaceBehavior*
    end


    /* replaces all instances of the current find word with the current replace 
    word using an offset if necessary to correctly replace the findWord indices 
    throughout the textBox. If the replaceField is empty, then the findWord is
    replaced with blank text. */
    action ReplaceAll(text findWord, text replaceWord)
        me:replaceWord = replaceWord
        if findIndices:GetSize() not= 0   
            integer replaceSize = replaceWord:GetSize()
            integer findSize = findWord:GetSize()
            integer offset = replaceSize - findSize
            integer startIndex = 0
            integer endIndex = 0

            integer i = 0
            repeat while i < findIndices:GetSize()
                if i not= 0
                    startIndex = ((findIndices:Get(i):GetFirstValue()) + (offset * i))
                    endIndex = ((findIndices:Get(i):GetSecondValue()) + (offset * i))
                else
                    startIndex = findIndices:Get(i):GetFirstValue()
                    endIndex = findIndices:Get(i):GetSecondValue()
                end
                Delete(startIndex, (endIndex + 1))
                Insert(startIndex, replaceWord)
                i = i + 1
            end
        end
    end

    /*
    When the CodeTextBox receives focus, it sets the project focus, if possible.
    */
    action GainedFocus(FocusEvent event)
        QuorumStudio studio = cast(QuorumStudio, gameStateManager:GetGame())
        StudioFocusManager focusManager = studio:GetStudioFocusManager()
        ProjectManager projectManager = studio:GetProjectManager()
        
        Project project = projectManager:IsProjectSourceFile(tab:GetFile())

        if project not= undefined
            focusManager:SetProjectFocus(project)
        end

        parent:TextBox:GainedFocus(event)
    end
end
